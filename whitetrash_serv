#!/usr/bin/env python

# Author: gregsfdev@users.sourceforge.net
# License: GPL
#
# This file is part of Whitetrash.
# 
#     Whitetrash is free software; you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation; either version 2 of the License, or
#     (at your option) any later version.
# 
#     Whitetrash is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
# 
#     You should have received a copy of the GNU General Public License
#     along with Whitetrash; if not, write to the Free Software
#     Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# 

import BaseHTTPServer, SimpleHTTPServer, SocketServer
import os,sys,time,cgi
import socket
import syslog
from base64 import decodestring
import re,urllib
import datetime
import MySQLdb
import MySQLdb.cursors
import whitetrash_db.DB as DB
import threading
from OpenSSL import SSL
from string import join
from whitetrash_db.configobj import ConfigObj

config = ConfigObj("/etc/whitetrash.conf")["DEFAULT"]

last_modified="Thu, 01 Jan 1970 00:00:00 GMT"
last_modified_not_whitelist="Thu, 01 Jan 1970 00:00:00 GMT"
proxy_secret_check=re.compile(config["proxy_secret"])
domain_re=re.compile("^([a-z0-9-]{1,50}\.){1,6}[a-z]{2,6}$")

class Log:
    """ The class for logging to a file.  Contains a flush after every write to ensure everything is logged even during an unexpected exit."""
    def __init__(self, f):
        self.f = f
    def write(self, s):
        self.f.write(s)
        self.f.flush()

def print_http_form(domain=None, url=None, clientaddr=None, username=None):

    return """
    <html>
    <head>
        <title>Internet Access Request Form</title>
        <style type="text/css" title="currentStyle" media="screen">
            @import "%s/whitetrash_server.css";
        </style>
    </head>

    <body>
        <div id="pageHeader"></div>
        <h1>Internet Access Request</h1>
        <form action="http://whitetrash" method="post">
        <div id="host"><div id="hostText"><p><b>Host Requested: </b></p></div><input name="domain" id="hostInputText" value="%s" maxlength="70" size="30" type="text"></div>
        <div id="requestDetails">
        <div id="requestDetailsText">
        <p><b>Protocol: </b>HTTP</p>
        <p><b>Client IP: </b>%s</p>
        <p><b>Client Username: </b>%s</p>
        </div>
        </div>
        <div id="centreContent">
        <p><b>Full Request: </b>%s</p>
        <div id="bnessReq">
        <p><b>This site is not currently in the whitelist.  If you have a genuine need to access this site please enter a business requirement or comment for this domain: </b><input name="comment" id="bnessInput" maxlength="100" size="40" type="text"></p></div>
        <div id="warningText">
        <p>By clicking "I Agree" below you are agreeing to have the information above stored on a list of whitelisted websites with YOUR UNIQUE USERNAME at <a href="http://viewwhitelist/whitelist.html">this address</a></p></div>
        <input type="hidden" name="url" value="%s">
        <input type="hidden" name="user" value="%s">
        <input type="hidden" name="protocol" value="HTTP">
        <input type="submit" name="consent" id="submit" value="I Agree" class="LgnBtn">
        </div>
        </form>
    </html>
    """ % (config["stylesheet_server"],domain,clientaddr,username,url,url,username)

def print_ssl_form(domain=None, url=None, clientaddr=None, username=None):

    return """
    <html>
    <head>
        <title>Internet Access Request Form</title>
        <style type="text/css" title="currentStyle" media="screen">
            @import "%s/whitetrash_server.css";
        </style>
    </head>

    <body>
        <div id="pageHeader"></div>
        <h1>Internet Access Request</h1>
        <form action="https://whitetrash" method="post">
        <div id="host"><div id="hostText"><p><b>Host Requested: </b></p></div><input name="domain" id="hostInputText" value="%s" maxlength="70" size="30" type="text"></div>
        <div id="requestDetails">
        <div id="requestDetailsText">
        <p><b>Protocol: </b>SSL</p>
        <p><b>Client Username: </b>%s</p>
        </div>
        </div>
        <div id="centreContent">
        <p><b>Full Request: </b>%s</p>
        <div id="bnessReq">
        <p><b>This site is not currently in the whitelist.  If you have a genuine need to access this site please enter a business requirement or comment for this domain: </b><input name="comment" id="bnessInput" maxlength="100" size="40" type="text"></p></div>
        <div id="warningText">
        <p>By clicking "I Agree" below you are agreeing to have the information above stored on a list of whitelisted websites with YOUR UNIQUE USERNAME at <a href="http://viewwhitelist/whitelist.html">this address</a></p></div>
        <input type="hidden" name="url" value="%s">
        <input type="hidden" name="user" value="%s">
        <input type="hidden" name="protocol" value="SSL">
        <input type="submit" name="consent" id="submit" value="I Agree" class="LgnBtn">
        </div>
        </form>

    </html>
    """ % (config["stylesheet_server"],domain,username,url,url,username)

class HTTPRequestHandler(SimpleHTTPServer.SimpleHTTPRequestHandler):

    def setup(self):
        SimpleHTTPServer.SimpleHTTPRequestHandler.setup(self)
        self.protocol="HTTP"
        self.auth_string=""
        self.ssl_username=""

    def failed(self,e):
        self.wfile.write("""
        <html>

        <head>
        <title>Whitetrash Error</title>
        <style type="text/css" title="currentStyle" media="screen">
            @import "%s/whitetrash_server.css";
        </style>

        </head>

        <body>

        <div id="pageHeader"></div>
        <div id="centreContent">
        <div id="errorText">
        <h1>Error</h1>
        <p>
        Please contact your friendly sysadmin.  Error details as follows:
        <p>
        <hr>
        <p>%s</p>
        </div>
        </div>

        </body>

        </html>

        """ % (config["stylesheet_server"],e))

    def success(self,orig_url,user,domain):
        dateobj=datetime
        self.wfile.write(""" 
        <html>

        <head>
        <title>Access Granted</title>
        <meta http-equiv=\"refresh\" CONTENT=\"1;URL=%s\">
        <style type="text/css" title="currentStyle" media="screen">
            @import "%s/whitetrash_server.css";
        </style>

        </head>

        <body>

        <div id="pageHeader"></div>
        <div id="requestDetails">
        <div id="requestDetailsText">
        <p><b>Timestamp: </b>%s</p>
        <p><b>Domain: </b>%s</p>
        <p><b>Client Username: </b>%s</p>
        </div>
        </div>
        
        <div id="centreContent">
        <h1>Thank you %s</h1>
        <p>
        Your access request for:</p>
        <p>%s</p>
        <p>has been granted.  Your browser should automatically take you to the website. If it doesn't you can use this link:</p>
        <p><a href=\"%s\">%s</a></p>
        </div>


        </body>

        </html>

        """ % (orig_url,config["stylesheet_server"],str(dateobj.datetime.now()),domain,user,user,orig_url,orig_url,orig_url))

    def convert_epoch(self,timestring):
        return time.mktime(time.strptime(timestring.strip(), "%a, %d %b %Y %H:%M:%S %Z"))

    def send_200(self,new_time,cache_age_secs,length):
        self.send_response(200, 'OK')
        #syslog.syslog("Sending 200, Last-Modified:%s" % new_time)
        self.send_header('Content-type','text/html')
        self.send_header("Accept-Ranges", "bytes")
        self.send_header("Cache-Control","max-age=%s" % cache_age_secs)
        
        ##Add an expires header for http 1.0 caches
        #convert to epoch and add cache age in seconds
        epoch=self.convert_epoch(new_time)+cache_age_secs
        age=time.strftime("%a, %d %b %Y %H:%M:%S",time.localtime(epoch))+" GMT"
        self.send_header("Expires",age)

        self.send_header('Content-length', length)
        self.send_header("Last-Modified",new_time)
        self.end_headers()

    def send_304(self,last_modified):
        self.send_response(304,"Not Modified")
        #syslog.syslog("Sending 304 Not Modified")
        self.send_header("Date",self.date_time_string())
        self.send_header("Last-Modified",last_modified)
        self.end_headers()

    def regenerate_whitelist(self,cache_age_in_seconds):
        """Create the html representing the whitelist from the database"""

        global last_modified

        #syslog.syslog("Regenerating whitelist webpage")
        dbh=DB.DBO()
#        dbh.execute("select whitelist_id,domain,timestamp,username,protocol,comment,originalrequest from whitelist order by username,whitelist_id")
        dbh.execute("select w.whitelist_id,domain,hitcount,w.timestamp as firsttime,h.timestamp as lasttime,username,protocol,comment,originalrequest from whitelist as w left join hitcount as h on w.whitelist_id=h.whitelist_id order by hitcount DESC")
        table=""
        #I don't unquote the original domain urllib.unquote(row[4]) due to the potential for code injection.
        for row in dbh:
            table+="<tr><td>%s</td><td>%s</td><td>%s</td><td>%s</td><td>%s</td><td>%s</td><td>%s</td><td>%s</td><td>%s</td></tr>\n" %(row['whitelist_id'],row['domain'],row["hitcount"],row['firsttime'],row["lasttime"],row['username'],row['protocol'],row['comment'],row['originalrequest'])
        whitelist_htmlpage="""

        <html>
        <head>
        <title>Whitetrash Whitelist Report</title>
        <style type="text/css" title="currentStyle" media="screen">
            @import "%s/whitetrash_server.css";
        </style>
        </head>

        <body>

        <div id="pageHeader"></div>
        <h1>Whitelist</h1>
        <div id="whitelistTable">
        <p>
        Use this report to find the sites getting the most whitelist hits.  To increase efficiency you should move really busy sites to a squid whitelist, thus minimising the necessary database accesses.</p>

        <p>Click <a href="http://viewwhitelist/not_whitelisted">here</a> for a list of domains that have been requested but not approved.</p>

        <p>Report generated at %s.
        </p>
        
        <table border=1 frame=box>
        <tr><td><b>ID</b></td><td><b>Whitelisted Domain</b></td><td><b>Domain Hitcount</b></td><td><b>First Whitelisted</b></td><td><b>Last Accessed</b></td><td><b>Whitelisted by User</b></td><td><b>Protocol</b></td><td><b>Comment</b></td><td><b>Original Request</b></td></tr>
        %s
        </table>
        </div>

        </body>
        </html>""" % (config["stylesheet_server"],time.asctime(),table)
        current_time=self.date_time_string()    
        last_modified=current_time
        self.send_200(current_time,cache_age_in_seconds,len(whitelist_htmlpage))

        self.wfile.write(whitelist_htmlpage)

    def regenerate_not_whitelist(self,cache_age_in_seconds):
        """Create the html representing the not_whitelist table from the database"""

        global last_modified_not_whitelist

        #syslog.syslog("Regenerating whitelist webpage")
        dbh=DB.DBO()
        dbh.execute("select not_whitelist_id, domain, username, protocol, firstseen, lastseen, hitcount from not_whitelisted order by hitcount DESC")
        table=""
        for row in dbh:
            table+="<tr><td>%s</td><td>%s</td><td>%s</td><td>%s</td><td>%s</td><td>%s</td></tr>\n" %(row['not_whitelist_id'],row['domain'],row['protocol'],row["firstseen"],row['lastseen'],row['hitcount'])
        whitelist_htmlpage="""

        <html>
        <head>
        <title>Whitetrash: *Not* Whitelist Report</title>
        <style type="text/css" title="currentStyle" media="screen">
            @import "%s/whitetrash_server.css";
        </style>
        </head>

        <body>

        <div id="pageHeader"></div>
        <div id="whitelistTable">
        <h2>Domains Requested but *NOT* Whitelisted</h2>
        <p>
        Use this report to find the sites getting hit a lot, but not whitellisted.  This probably indicates malware or banner ad domains.  To increase efficiency you should move really busy sites to a squid blacklist, thus minimising the necessary database accesses.<p>

        <p>Report generated at %s.
        </p>
        
        <table border=1 frame=box>
        <tr><td><b>ID</b></td><td><b>Domain</b></td><td><b>Protocol</b></td><td><b>First Requested</b></td><td><b>Last Requested</b></td><td><b>Hitcount</b></td></tr>
        %s
        </table>
        </div>

        </body>
        </html>""" % (config["stylesheet_server"],time.asctime(),table)
        current_time=self.date_time_string()    
        last_modified_not_whitelist=current_time
        self.send_200(current_time,cache_age_in_seconds,len(whitelist_htmlpage))

        self.wfile.write(whitelist_htmlpage)


    def generate_webpage(self,last_modified,regenerate_webpage):
        """I was originally caching this page locally, but it is much simpler and performs better if I just set the If-Modified-Since header and let squid do the caching!
        This approach is much better, as the page only gets regenerated if it has been requested.  Before I was using a cron which always ran, regardless of whether anyone
        was actually interested.

        This is mainly for my benefit to remember how this works:

        - Firefox respects the max-age caching directive and will not ask squid for a new copy of the page unless the time has expired, OR the user hits refresh.  If the user
        refreshes, firefox adds a "Cache-Control: max-age=0" header to the request.
        - Squid will always treat a max-age=0 as a MISS and ask the server for a new copy.  If there is no max-age=0 and the cache time hasn't expired, squid will treat
        it as a HIT.
        - Firefox only supplies a IMS header with the request if it receive a Last-Modified header with the last response. IMS *is sent* with a refresh. 
        
        """

        try:

            #syslog.syslog("Full Request Headers: %s" % self.headers)
            try:
            
                if (time.time() + time.timezone - self.convert_epoch(last_modified) > int(config["cache_age_in_seconds"])):
                    #syslog.syslog("Time difference:%s"% (time.time() +time.timezone - self.convert_epoch(last_modified)))
                    #Time to refresh -force a reload through the IF condition below
                    last_modified="Thu, 01 Jan 1970 00:00:00 GMT"
                    
                #syslog.syslog("IMS from request: %s.  Our last modified time: %s" % (self.headers['If-Modified-Since'],last_modified))

                if self.headers['If-Modified-Since']==last_modified:
                    self.send_304(last_modified)
                else:
                    regenerate_webpage(int(config["cache_age_in_seconds"]))
            except KeyError:
                #No IMS header so we have to regenerate
                regenerate_webpage(int(config["cache_age_in_seconds"]))

        except Exception,e:
            self.failed("Error running whitelist html page generation: %s" %e)

    def domain_sanitise(self,domain):
        #Make sure it is of something.com format
        domain_res=domain_re.match(domain)
        if domain_res:
            #Domain is valid.
            domain=domain_res.group()
            return re.sub("^www[0-9]?\.","",domain,1)
        else:
            #Decided to fail rather than change to a valid domain name.
            self.failed("Bad domain name")
            return False


    def add_to_whitelist(self,form,authenticated_user):
        """Take the filled out form, sanity check and add entry to the whitelist.

        Here are the reasons why I don't store src (client) IP address in the database:

        SSL - You know it at the redirector, but there is no way to pass this info back to whitetrash_serv.  You 
        can use X-Forwarded-For header but it has to be enabled (not a great idea) and if it is on, chances are the squid
        admin will be re-writing it with generic values to protect their internal IP addresses.  So ultimately it is not reliable.

        HTTP - You know it reliably when you get the form GET, but since you don't save state between the GET and the form POST, there
        is nowhere to store it.  You can put it in the form, but the user could change this value when it is posted so even though this
        is unlikely the value is not reliable.

        Long story short.  If you want to know IPs, you have username, domain, and timestamp - go look through the logs
        """

        try:
            #All of these fields need to be sanitised.
            orig_comment=str(form.getfirst("comment"))[:DB.COMMENT_LEN]
            orig_url=str(form.getfirst("url"))[:DB.URL_LEN]
            #User comes from squid so we trust it
            user=str(form.getfirst("user"))[:DB.USER_LEN]
            domain=str(form.getfirst("domain"))[:DB.DOMAIN_LEN]
            protocol=str(form.getfirst("protocol")).upper()
            if orig_url and domain and protocol:

                if (protocol !="HTTP" and protocol!="SSL"):
                    self.failed("Bad protocol, only HTTP and SSL handled")

                else:
                
                    if (protocol=="HTTP") and (authenticated_user != user):
                        # We don't get this info for SSL, so just check if it is HTTP
                        # Doesn't matter too much since we ignore the form value anyway
                        self.failed("Invalid user authentication")

                    else:

                        #Only trust the user provided by squid, not the one from the form.    
                        user=authenticated_user

                        if not orig_comment:
                            orig_comment="None"

                        #Quote the url to get rid of any dangerous stuff for the DB, but still display the proper text when viewed in a browser.
                        url=urllib.quote(orig_url.lower())
                        #Only allow sane text in the comment.
                        comment=re.sub("[^a-zA-Z0-9- .,!]+","",orig_comment)

                        #sanitise domain
                        domain=self.domain_sanitise(form.getfirst("domain").lower())
                        if domain:

                            try:
                                #Don't worry about inserting a row into the hitcount, I do that in the whitelister.
                                dbh=DB.DBO()
                                dbh.execute("insert into whitelist set domain=%r,timestamp=NOW(),username=%r,protocol=%r,originalrequest=%r,comment=%r", (domain,user,protocol,url,comment))
                                #Need to remove any entry from the not_whitelisted table
                                dbh.execute("delete from not_whitelisted where domain=%r and protocol=%r", (domain,protocol))
                                self.success(orig_url,user,domain)
                            except Exception,e:
                                self.failed(e)

            else:
                self.failed("Incomplete fields")
        except Exception,e:
            self.failed("Invalid input:%s" % e)

    def do_POST(self):

        try:

            if self.protocol=="SSL":
                uname=self.ssl_username
            else:
                #Get the username and the "secret" passed by squid.
                #Header looks like: "Basic sldkfjlssjd\r\n"
                (uname,secret)=decodestring(self.headers['Proxy-Authorization'].split()[1]).split(":")

        except Exception,e:
            if self.protocol=="SSL":
                message = "do_POST: Problem decoding authorization string (Proxy-Authorization: %s) '%s'" % self.auth_string,e
            else:
                message = "do_POST: Problem decoding authorization string (Proxy-Authorization: %s) '%s'" % self.headers['Proxy-Authorization'],e
            self.failed(message)

        try:
           
            if (self.protocol=="HTTP" and proxy_secret_check.match(secret)) or (self.protocol=="SSL"):

                if uname.isalnum():
                    #This is a simple check
                    #Username is alpha-numeric
                    env = {}
                    env['GATEWAY_INTERFACE'] = 'CGI/1.1'
                    env['SERVER_PROTOCOL'] = self.protocol_version
                    env['REQUEST_METHOD'] = self.command
                    if self.headers.typeheader is None:
                        env['CONTENT_TYPE'] = self.headers.type
                    else:
                        env['CONTENT_TYPE'] = self.headers.typeheader

                    length = self.headers.getheader('content-length')
                    if length:
                        env['CONTENT_LENGTH'] = length

                    form = cgi.FieldStorage(fp=self.rfile,headers = None, environ=env)
                    self.add_to_whitelist(form,uname)
                else:
                    #User name invalid
                    self.failed("Expecting alphanumeric username, got:%s" % uname)
            else:
                self.failed("Invalid cache_peer password for whitetrash")

        except Exception,e:
            self.failed(e) 
        
    def do_GET(self):

        if self.path.startswith("http://viewwhitelist"):
            
            if self.path.startswith("http://viewwhitelist/not_whitelisted"):
                global last_modified_not_whitelist
                self.generate_webpage(last_modified_not_whitelist,self.regenerate_not_whitelist)
            else:
                global last_modified
                self.generate_webpage(last_modified,self.regenerate_whitelist)

        else:
            try:
                dbh=DB.DBO()
                if self.protocol=="SSL":
                    host = self.domain_sanitise(self.headers["Host"])
                    if host:
                        self.wfile.write(print_ssl_form(domain=host,url="https://%s%s" % (self.headers["Host"],self.path),clientaddr="0.0.0.0",username=self.ssl_username))
                        dbh.execute("insert into not_whitelisted set domain=%r, username=%r, protocol=%r, firstseen=NOW(), lastseen=NOW(), hitcount=1 on duplicate key update lastseen=NOW(), hitcount=hitcount+1",(host,self.ssl_username,"SSL"))
                else:
                    param_start=self.path.index("?")
                    results=cgi.parse_qs(self.path[param_start+1:].replace("?","%3F"))
                    dom=self.domain_sanitise(results["domain"][0])
                    if dom:
                        self.wfile.write(print_http_form(url=results["url"][0],domain=results["domain"][0],clientaddr=results["clientaddr"][0],username=results["clientident"][0]))
                        dbh.execute("insert into not_whitelisted set domain=%r, username=%r, protocol=%r, firstseen=NOW(), lastseen=NOW(), hitcount=1 on duplicate key update lastseen=NOW(), hitcount=hitcount+1",(dom,results["clientident"][0],"HTTP"))
            except KeyError,e:
                self.failed("Invalid domain requested")
            except Exception,e:
                self.failed("Error:%s. Path:%s" % (e,self.path))

    def do_CONNECT(self):
        self.auth_string=self.headers['Proxy-Authorization']
        self.ssl_username=decodestring(self.auth_string.split(" ")[1]).split(":")[0]
        self.send_response(200, 'OK')
        self.end_headers()

        #Switch our socket to SSL
        ctx = SSL.Context(SSL.SSLv23_METHOD)
        #server.pem's location (containing the server private key and
        #the server certificate).
        ctx.use_privatekey_file (config["ssl_server_certificate"])
        ctx.use_certificate_file(config["ssl_server_certificate"])
        ssl_socket = SSL.Connection(ctx, self.wfile)
        self.rfile = socket._fileobject(ssl_socket, "rb", self.rbufsize)
        self.wfile = socket._fileobject(ssl_socket, "wb", self.wbufsize)
        ssl_socket.set_accept_state()
        self.protocol="SSL"
        self.handle()


class WhitetrashServer(SocketServer.ThreadingMixIn, BaseHTTPServer.HTTPServer):
    pass

def run_http(server_class=WhitetrashServer,
        handler_class=HTTPRequestHandler):
    server_address = (config["server_address"], int(config["server_port"]))
    httpd = server_class(server_address, handler_class)
    syslog.openlog('whitetrash_serv',0,syslog.LOG_DAEMON)     
    PIDFILE = config["pidfile"]
    DAEMON = True 
    LOGFILE = config["logfile"]

    if (DAEMON):
        # Unix double-fork magic
        try:
            pid = os.fork()
            if pid > 0:
                # exit first parent
                sys.exit(0)
        except OSError, e:
            print >>sys.stderr, "fork #1 failed: %d (%s)" % (e.errno, e.strerror)
            sys.exit(1)

        # decouple from parent environment
        os.chdir("/")   # don't prevent unmounting
        os.setsid()
        os.umask(0)

        # do second fork
        try:
            pid = os.fork()
            if pid > 0:
                # exit from second parent, print eventual PID before
                open(PIDFILE,'w').write("%d"%pid)
                sys.exit(0)
        except OSError, e:
            print >>sys.stderr, "fork #2 failed: %d (%s)" % (e.errno, e.strerror)
            sys.exit(1)
    
    
        # redirect outputs to a log file
        sys.stdout = sys.stderr = Log(open(LOGFILE, 'a+'))
	syslog.syslog("***** Whitetrash Server Started - %s *****" % (str(time.asctime())))

    httpd.serve_forever()

run_http()



