#!/usr/bin/env python

# Author: gregsfdev@users.sourceforge.net
# License: GPL
#
# This file is part of Whitetrash.
# 
#     Whitetrash is free software; you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation; either version 2 of the License, or
#     (at your option) any later version.
# 
#     Whitetrash is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
# 
#     You should have received a copy of the GNU General Public License
#     along with Whitetrash; if not, write to the Free Software
#     Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# 

import BaseHTTPServer, SimpleHTTPServer, SocketServer
import os,sys,time,cgi
import socket
import syslog
from base64 import decodestring
import re,urllib
import datetime
import MySQLdb
import MySQLdb.cursors
import whitetrash_db.DB as DB
import threading
from OpenSSL import SSL
from string import join
from whitetrash_db.configobj import ConfigObj
from random import randint

config = ConfigObj("/etc/whitetrash.conf")["DEFAULT"]
try:
    import cmemcache 
    cache=cmemcache.StringClient(config["memcache_servers"].split(","))
except ImportError:
    print "cmemcache not installed, ensure it is disabled in whitetrash.conf"

try:
    from Captcha.Visual.Tests import PseudoGimpy
    from Captcha import Factory
except ImportError:
    print "PyCaptcha not installed.  Download from http://cheeseshop.python.org/pypi/PyCAPTCHA/0.4\nAlso requires Python imaging library."

last_modified="Thu, 01 Jan 1970 00:00:00 GMT"
last_modified_not_whitelist="Thu, 01 Jan 1970 00:00:00 GMT"
captcha_factory=Factory()

class Log:
    """ The class for logging to a file.  Contains a flush after every write to ensure everything is logged even during an unexpected exit."""
    def __init__(self, f):
        self.f = f
    def write(self, s):
        self.f.write(s)
        self.f.flush()


class WTHTTPRequestHandler(SimpleHTTPServer.SimpleHTTPRequestHandler):

    def setup(self):
        SimpleHTTPServer.SimpleHTTPRequestHandler.setup(self)
        self.protocol="HTTP"
        self.captcha_id_length=24
        self.auth_string=""
        self.ssl_username=""
        self.proxy_secret_check=re.compile(config["proxy_secret"])
        self.domain_re=re.compile(config["domain_regex"])
        self.user_deletion_allowed=config["user_deletion_allowed"].upper()=="TRUE"

        self.whitetrash_admin_path="http://%s" % config["whitetrash_admin_domain"]
        self.add_path="http://%s/addentry" % config["whitetrash_add_domain"]
        self.captcha_path="http://%s/captcha/" % config["whitetrash_captcha_domain"]
        self.ssl_add_path=self.add_path.replace("http","https")
        self.delete_path="%s/deleteentry" % self.whitetrash_admin_path
        self.admins = config["admins"].split(",")
        self.debug=config["debug"].upper()=="TRUE"
        self.captcha_ssl=config["captcha_ssl"].upper()=="TRUE"
        self.captcha_http=config["captcha_http"].upper()=="TRUE"


    def print_form(self,domain=None, url=None, clientaddr=None, username=None):
        global captcha_factory
        newcaptcha_id=captcha_factory.new(PseudoGimpy).id
        if (self.captcha_http and self.protocol=="HTTP") or (self.captcha_ssl and self.protocol=="SSL"):
            captcha_data="""
                <div id="captchaContent">
                <p><img id="captchaImage" src="%s%s"/></p>
                <p>Enter the word shown: <input type="text" name="captchatext" maxlength="100" size="20"/></p>
                <input type="hidden" name="captchaID" value="%s">
                </div>
            """ % (self.captcha_path,newcaptcha_id,newcaptcha_id)
        else:
            captcha_data=""

        if clientaddr:
            client_ip="<p><b>Client IP: </b>%s</p>" % clientaddr
        else:
            client_ip=""

        if self.protocol=="HTTP":
            add_path=self.add_path
        else:
            add_path=self.ssl_add_path

        return """
        <html>
        <head>
            <title>Internet Access Request Form</title>
            <style type="text/css" title="currentStyle" media="screen">
                @import "%s/whitetrash_server.css";
            </style>
        </head>

        <body>
            <div id="pageHeader"></div>
            <h1>Internet Access Request</h1>
            <form action="%s" method="post">
            <div id="host"><div id="hostText"><p><b>Host Requested: </b></p></div><input name="domain" id="hostInputText" value="%s" maxlength="70" size="30" type="text"></div>
            <div id="requestDetails">
            <div id="requestDetailsText">
            <p><b>Protocol: </b>%s</p>
            %s
            <p><b>Client Username: </b>%s</p>
            </div>
            </div>
            <div id="centreContent">
            <p><b>Full Request: </b>%s</p>
            <div id="bnessReq">
            <p><b>This site is not currently in the whitelist.  If you have a genuine need to access this site please enter a business requirement or comment for this domain: </b><input name="comment" id="bnessInput" maxlength="100" size="40" type="text"></p></div>
            <div id="warningText">
            <p>By clicking "I Agree" below you are agreeing to have the information above stored on a list of whitelisted websites with YOUR UNIQUE USERNAME at <a href="%s/whitelist.html">this address</a></p></div>
            <input type="hidden" name="url" value="%s">
            <input type="hidden" name="user" value="%s">
            <input type="hidden" name="protocol" value="%s">
            %s
            <input type="submit" name="consent" id="submit" value="I Agree" class="LgnBtn">
            </div>
            </form>
        </html>
        """ % (config["stylesheet_server"],add_path,domain,self.protocol,client_ip,username,url,self.whitetrash_admin_path,url,username,self.protocol,captcha_data)

    def failed_captcha(self,url):
        self.wfile.write("""
        <html>
        <head>
        <title>Whitetrash Error</title>
        <style type="text/css" title="currentStyle" media="screen">
            @import "%s/whitetrash_server.css";
        </style>
        <meta http-equiv=\"refresh\" CONTENT=\"3;URL=%s\">
        </head>
        <body>

        <div id="pageHeader"></div>
        <div id="centreContent">
        <div id="errorText">
        <h1>Error</h1>
        <p>
        Incorrect word entered.  Click the link below or wait for this page to refresh to try again.
        </div>
        <hr>
        <a href=%s>%s</a>
        </div>

        </body>
        </html>

        """ % (config["stylesheet_server"],url,url,url))


    def failed_screen(self,e):
        safe_e=re.sub("[^a-zA-Z0-9- .,()\"\']+","",e)
        self.wfile.write("""
        <html>
        <head>
        <title>Whitetrash Error</title>
        <style type="text/css" title="currentStyle" media="screen">
            @import "%s/whitetrash_server.css";
        </style>
        </head>
        <body>

        <div id="pageHeader"></div>
        <div id="centreContent">
        <div id="errorText">
        <h1>Error</h1>
        <p>
        Please contact your friendly sysadmin.  Error details as follows:
        <p>
        <hr>
        <p>%s</p>
        </div>
        </div>

        </body>
        </html>

        """ % (config["stylesheet_server"],safe_e))

    def failed(self,e):
        """Hide our detailed serious errors inline with best practice.  Use failed_screen for errors that will be meaningful to users but don't disclose security information."""
        if self.debug:
            self.failed_screen(e)
        else:
            code=randint(1,65536)
            self.failed_screen("Error ID:%s" % code)
            syslog.syslog("Error ID:%s, Message:%s" % (code,e))

    def keys_deleted(self):
        self.wfile.write("""
        <html>
        <head>
        <meta http-equiv=\"refresh\" CONTENT=\"1;URL=%s\">
        <title>Whitelist Entries Deleted</title>
        <style type="text/css" title="currentStyle" media="screen">
            @import "%s/whitetrash_server.css";
        </style>
        </head>
        <body>
        <div id="pageHeader"></div>
        <div id="centreContent">
        <h1>Whitelist Entries Deleted.</h1>
        </div>
        </body>
        </html>

        """ % (self.delete_path,config["stylesheet_server"]))

    def success(self,orig_url,user,domain):
        dateobj=datetime
        self.wfile.write(""" 
        <html>
        <head>
        <title>Access Granted</title>
        <meta http-equiv=\"refresh\" CONTENT=\"1;URL=%s\">
        <style type="text/css" title="currentStyle" media="screen">
            @import "%s/whitetrash_server.css";
        </style>
        </head>
        <body>

        <div id="pageHeader"></div>
        <div id="requestDetails">
        <div id="requestDetailsText">
        <p><b>Timestamp: </b>%s</p>
        <p><b>Domain: </b>%s</p>
        <p><b>Client Username: </b>%s</p>
        </div>
        </div>
        
        <div id="centreContent">
        <h1>Thank you %s</h1>
        <p>
        Your access request for:</p>
        <p>%s</p>
        <p>has been granted.  Your browser should automatically take you to the website. If it doesn't you can use this link:</p>
        <p><a href=\"%s\">%s</a></p>
        </div>
        </body>
        </html>

        """ % (orig_url,config["stylesheet_server"],str(dateobj.datetime.now()),domain,user,user,orig_url,orig_url,orig_url))

    def convert_epoch(self,timestring):
        return time.mktime(time.strptime(timestring.strip(), "%a, %d %b %Y %H:%M:%S %Z"))

    def send_200(self,new_time,cache_age_secs,length):
        self.send_response(200, 'OK')
        #syslog.syslog("Sending 200, Last-Modified:%s" % new_time)
        self.send_header('Content-type','text/html')
        self.send_header("Accept-Ranges", "bytes")
        self.send_header("Cache-Control","max-age=%s" % cache_age_secs)
        
        ##Add an expires header for http 1.0 caches
        #convert to epoch and add cache age in seconds
        epoch=self.convert_epoch(new_time)+cache_age_secs
        age=time.strftime("%a, %d %b %Y %H:%M:%S",time.localtime(epoch))+" GMT"
        self.send_header("Expires",age)

        self.send_header('Content-length', length)
        self.send_header("Last-Modified",new_time)
        self.end_headers()

    def send_304(self,last_modified):
        self.send_response(304,"Not Modified")
        #syslog.syslog("Sending 304 Not Modified")
        self.send_header("Date",self.date_time_string())
        self.send_header("Last-Modified",last_modified)
        self.end_headers()

    def regenerate_whitelist(self,cache_age_in_seconds):
        """Create the html representing the whitelist from the database"""

        global last_modified

        #syslog.syslog("Regenerating whitelist webpage")
        dbh=DB.DBO()
#        dbh.execute("select whitelist_id,domain,timestamp,username,protocol,comment,originalrequest from whitelist order by username,whitelist_id")
        dbh.execute("select w.whitelist_id,domain,hitcount,w.timestamp as firsttime,h.timestamp as lasttime,username,protocol,comment,originalrequest from whitelist as w left join hitcount as h on w.whitelist_id=h.whitelist_id order by hitcount DESC")
        table=""
        #I don't unquote the original domain urllib.unquote(row[4]) due to the potential for code injection.
        for row in dbh:
            table+="<tr><td>%s</td><td>%s</td><td>%s</td><td>%s</td><td>%s</td><td>%s</td><td>%s</td><td>%s</td><td>%s</td></tr>\n" %(row['whitelist_id'],row['domain'],row["hitcount"],row['firsttime'],row["lasttime"],row['username'],row['protocol'],row['comment'],row['originalrequest'])
        whitelist_htmlpage="""

        <html>
        <head>
        <title>Whitetrash Whitelist Report</title>
        <style type="text/css" title="currentStyle" media="screen">
            @import "%s/whitetrash_server.css";
        </style>
        </head>

        <body>

        <div id="pageHeader"></div>
        <h1>Whitelist</h1>
        <div id="whitelistTable">
        <p>
        Use this report to find the sites getting the most whitelist hits.  To increase efficiency you should move really busy sites to a squid whitelist, thus minimising the necessary database accesses.</p>

        <p>Click <a href="%s/not_whitelisted">here</a> for a list of domains that have been requested but not approved.</p>

        <p>Click <a href="%s">here</a> to remove domains from the whitelist.</p>

        <p>Report generated at %s.
        </p>
        
        <table border=1 frame=box>
        <tr><td><b>ID</b></td><td><b>Whitelisted Domain</b></td><td><b>Domain Hitcount</b></td><td><b>First Whitelisted</b></td><td><b>Last Accessed</b></td><td><b>Whitelisted by User</b></td><td><b>Protocol</b></td><td><b>Comment</b></td><td><b>Original Request</b></td></tr>
        %s
        </table>
        </div>

        </body>
        </html>""" % (config["stylesheet_server"],self.whitetrash_admin_path,self.delete_path,time.asctime(),table)
        current_time=self.date_time_string()    
        last_modified=current_time
        self.send_200(current_time,cache_age_in_seconds,len(whitelist_htmlpage))

        self.wfile.write(whitelist_htmlpage)

    def regenerate_not_whitelist(self,cache_age_in_seconds):
        """Create the html representing the not_whitelist table from the database"""

        global last_modified_not_whitelist

        #syslog.syslog("Regenerating whitelist webpage")
        dbh=DB.DBO()
        dbh.execute("select not_whitelist_id, domain, username, protocol, firstseen, lastseen, hitcount from not_whitelisted order by hitcount DESC")
        table=""
        for row in dbh:
            table+="<tr><td>%s</td><td>%s</td><td>%s</td><td>%s</td><td>%s</td><td>%s</td></tr>\n" %(row['not_whitelist_id'],row['domain'],row['protocol'],row["firstseen"],row['lastseen'],row['hitcount'])
        whitelist_htmlpage="""

        <html>
        <head>
        <title>Whitetrash: *Not* Whitelist Report</title>
        <style type="text/css" title="currentStyle" media="screen">
            @import "%s/whitetrash_server.css";
        </style>
        </head>

        <body>

        <div id="pageHeader"></div>
        <div id="whitelistTable">
        <h2>Domains Requested but *NOT* Whitelisted</h2>
        <p>
        Use this report to find the sites getting hit a lot, but not whitellisted.  This probably indicates malware or banner ad domains.  To increase efficiency you should move really busy sites to a squid blacklist, thus minimising the necessary database accesses.<p>

        <p>Report generated at %s.
        </p>
        
        <table border=1 frame=box>
        <tr><td><b>ID</b></td><td><b>Domain</b></td><td><b>Protocol</b></td><td><b>First Requested</b></td><td><b>Last Requested</b></td><td><b>Hitcount</b></td></tr>
        %s
        </table>
        </div>

        </body>
        </html>""" % (config["stylesheet_server"],time.asctime(),table)
        current_time=self.date_time_string()    
        last_modified_not_whitelist=current_time
        self.send_200(current_time,cache_age_in_seconds,len(whitelist_htmlpage))

        self.wfile.write(whitelist_htmlpage)

    def print_delete_page(self,dbh,uname):
        table=""
        for row in dbh:
            table+='<tr><td><input type="checkbox" name="DeleteId" value="%s"></td><td>%s</td><td>%s</td><td>%s</td><td>%s</td><td>%s</td></tr>\n' %(row['whitelist_id'],row['whitelist_id'],row['domain'],row['timestamp'],row['protocol'],row['comment'])

        whitelist_htmlpage="""

        <html>
        <head>
        <title>Whitetrash: Deletion Interface for %s</title>
        <style type="text/css" title="currentStyle" media="screen">
            @import "%s/whitetrash_server.css";
        </style>
        </head>

        <body>

        <div id="pageHeader"></div>
        <div id="whitelistTable">
        <h2>Domains Whitelisted by %s</h2>
        <p>
        To delete entries, tick those you want to delete and hit the "Delete" button.<p>

        <p>Report generated at %s.
        </p>
        <form name="delete" action="%s" method="POST"> 
        <table border=1 frame=box>
        <tr><td><b>Delete</b></td><td><b>ID</b></td><td><b>Whitelisted Domain</b></td><td><b>First Whitelisted</b></td><td><b>Protocol</b></td><td><b>Comment</b></td></tr>
        %s
        </table>
        <p>
        <input type="submit" name="Delete" id="Delete" value="Delete domains" class="LgnBtn"></p>
        </form>
        </div>

        </body>
        </html>""" % (uname,config["stylesheet_server"],uname,time.asctime(),self.delete_path,table)
        self.send_200(self.date_time_string(),0,len(whitelist_htmlpage))
        self.wfile.write(whitelist_htmlpage)


    def generate_delete_list(self,uname):
        try:
            dbh=DB.DBO()
            if uname in self.admins:
                dbh.execute("select whitelist_id,domain,timestamp,protocol,comment from whitelist order by timestamp DESC")
                uname="all users"
                self.print_delete_page(dbh,uname)
            elif self.user_deletion_allowed:
                dbh.execute("select whitelist_id,domain,timestamp,protocol,comment from whitelist where username=%r order by timestamp DESC", uname)
                self.print_delete_page(dbh,uname)
            else:
                self.failed_screen("Delete access not authorised")
        except Exception,e:
            self.failed("Database error when generating deleted items list: %s" % e)

    def generate_webpage(self,last_modified,regenerate_webpage):
        """I was originally caching this page locally, but it is much simpler and performs better if I just set the If-Modified-Since header and let squid do the caching!
        This approach is much better, as the page only gets regenerated if it has been requested.  Before I was using a cron which always ran, regardless of whether anyone
        was actually interested.

        This is mainly for my benefit to remember how this works:

        - Firefox respects the max-age caching directive and will not ask squid for a new copy of the page unless the time has expired, OR the user hits refresh.  If the user
        refreshes, firefox adds a "Cache-Control: max-age=0" header to the request.
        - Squid will always treat a max-age=0 as a MISS and ask the server for a new copy.  If there is no max-age=0 and the cache time hasn't expired, squid will treat
        it as a HIT.
        - Firefox only supplies a IMS header with the request if it receive a Last-Modified header with the last response. IMS *is sent* with a refresh. 
        
        """

        try:

            #syslog.syslog("Full Request Headers: %s" % self.headers)
            try:
            
                if (time.time() + time.timezone - self.convert_epoch(last_modified) > int(config["cache_age_in_seconds"])):
                    #syslog.syslog("Time difference:%s"% (time.time() +time.timezone - self.convert_epoch(last_modified)))
                    #Time to refresh -force a reload through the IF condition below
                    last_modified="Thu, 01 Jan 1970 00:00:00 GMT"
                    
                #syslog.syslog("IMS from request: %s.  Our last modified time: %s" % (self.headers['If-Modified-Since'],last_modified))

                if self.headers['If-Modified-Since']==last_modified:
                    self.send_304(last_modified)
                else:
                    regenerate_webpage(int(config["cache_age_in_seconds"]))
            except KeyError:
                #No IMS header so we have to regenerate
                regenerate_webpage(int(config["cache_age_in_seconds"]))

        except Exception,e:
            self.failed("Error running whitelist html page generation: %s" %e)

    def domain_sanitise(self,domain):
        #Make sure it is of something.com format
        domain_res=self.domain_re.match(domain)
        if domain_res and (len(domain) < DB.DOMAIN_LEN) and (domain!=config["domain_fail_string"]):
            #Domain is valid.
            domain=domain_res.group()
            return re.sub("^www[0-9]?\.","",domain,1)
        else:
            #Decided to fail rather than change to a valid domain name.
            self.failed_screen("Bad domain name")
            return False

    
    def add_to_db(self,domain,user,protocol,url,comment,orig_url):
        try:
            #Don't worry about inserting a row into the hitcount, I do that in the whitelister.
            dbh=DB.DBO()
            dbh.execute("insert into whitelist set domain=%r,timestamp=NOW(),username=%r,protocol=%r,originalrequest=%r,comment=%r", (domain,user,protocol,url,comment))
            #Need to remove any entry from the not_whitelisted table
            dbh.execute("delete low_priority from not_whitelisted where domain=%r and protocol=%r", (domain,protocol))
            self.success(orig_url,user,domain)
        except Exception,e:
            self.failed(e)

        
    def add_to_whitelist(self,form,authenticated_user):
        """Take the filled out form, sanity check and add entry to the whitelist.

        Here are the reasons why I don't store src (client) IP address in the database:

        SSL - You know it at the redirector, but there is no way to pass this info back to whitetrash_serv.  You 
        can use X-Forwarded-For header but it has to be enabled (not a great idea) and if it is on, chances are the squid
        admin will be re-writing it with generic values to protect their internal IP addresses.  So ultimately it is not reliable.

        HTTP - You know it reliably when you get the form GET, but since you don't save state between the GET and the form POST, there
        is nowhere to store it.  You can put it in the form, but the user could change this value when it is posted so even though this
        is unlikely the value is not reliable.

        Long story short.  If you want to know IPs, you have username, domain, and timestamp - go look through the logs
        """
        
        def check_captcha(id,user_response):
            global captcha_factory
            test = captcha_factory.get(id)
            if id.isalnum() and user_response.isalpha():
                if (test) and (test.valid) and test.testSolutions([user_response]):
                    return True
            self.failed_captcha(orig_url)
            return False

        try:
            user=str(form.getfirst("user"))
            domain=str(form.getfirst("domain"))
            #Don't care if comment or orig_url gets truncated.
            orig_comment=str(form.getfirst("comment"))[:DB.COMMENT_LEN]
            orig_url=str(form.getfirst("url"))[:DB.URL_LEN]
            protocol=str(form.getfirst("protocol"))
            if (orig_url!="None") and (domain!="None") and (protocol!="None"):
                
                if (protocol !="HTTP" and protocol!="SSL"):
                    self.failed_screen("Bad protocol, only HTTP and SSL handled")

                else:
                
                    if (protocol=="HTTP") and (authenticated_user != user):
                        # We don't get this info for SSL, so just check if it is HTTP
                        # Doesn't matter too much since we ignore the form value anyway
                        self.failed_screen("Invalid user authentication")
                        syslog.syslog("User with squid authentication: %s attempted to add a domain as user: %s" % (authenticated_user, user))

                    else:

                        # Only trust the user provided by squid auth header.
                        # This input from squid has already been sanitised.
                        user=authenticated_user

                        if not orig_comment:
                            orig_comment="None"

                        #Quote the url to get rid of any dangerous stuff for the DB, but still display the proper text when viewed in a browser.
                        url=urllib.quote(orig_url.lower())
                        #Only allow sane text in the comment.
                        comment=re.sub("[^a-zA-Z0-9- .,!]+","",orig_comment)

                        #sanitise domain
                        domain=self.domain_sanitise(form.getfirst("domain").lower())
                        if domain:
                            if (protocol=="HTTP" and self.captcha_http) or (protocol=="SSL" and self.captcha_ssl):
                                if check_captcha(str(form.getfirst("captchaID")),str(form.getfirst("captchatext"))):
                                    self.add_to_db(domain,user,protocol,url,comment,orig_url)
                            else:
                                self.add_to_db(domain,user,protocol,url,comment,orig_url)
                       
            else:
                self.failed_screen("Incomplete fields.  The usual cause of this problem is that you are trying to submit a form over SSL to a domain that is not currently in the whitelist.  Add the SSL domain to the whitelist and re-submit the form.")
        except Exception,e:
            self.failed("Invalid input to add_to_whitelist:%s" % e)

    def do_delete(self,delete_statement,args):
        """Perform the delete from database.  Own method to allow overriding for memcached"""
        dbh=DB.DBO()
        dbh.execute(delete_statement, args)
        self.keys_deleted()

    def delete_from_whitelist(self,form,authenticated_user):
        try:
            ids=form.getvalue("DeleteId")
            if ids.__class__.__name__=='list':
                #we have more than one selected.
                for id in ids:
                    if int(id)<=0:
                        self.failed_screen("Bad id submitted for deletion")
                id_list=join(ids,"','")
            else:
                id_list=ids
            if authenticated_user in self.admins:
                self.do_delete("delete low_priority from whitelist where whitelist_id IN ('%s')", (id_list))
            elif self.user_deletion_allowed:
                self.do_delete("delete low_priority from whitelist where username=%r and whitelist_id IN ('%s')", (str(authenticated_user),id_list))
            else:
                self.failed_screen("Deletion access denied")

        except DB.DBError,e:
            self.failed("Database error when deleting values:%s" % e)
        except Exception,e:
            self.failed("Bad id submitted for deletion:%s" %e)
        
    def check_uname_secret(self):
        """Get the username and the "secret" passed by squid.
        Check the secret matches and that the username is alphanumeric
        Header looks like: "Basic sldkfjlssjd\r\n" """
        try:
            if self.protocol=="SSL":
                if (self.ssl_username.isalpha()) and (len(self.ssl_username) < DB.USER_LEN):
                    return self.ssl_username
                else:
                    self.failed("Invalid username (not alphabetic)")
            else:
                (uname,secret)=decodestring(self.headers['Proxy-Authorization'].split()[1]).split(":")
                if (self.proxy_secret_check.match(secret) and uname.isalpha() and (len(self.ssl_username) < DB.USER_LEN)):
                    return uname
                else:
                    self.failed("Invalid username or cache_peer password for whitetrash")
        except Exception, e:
            self.failed("Problem decoding proxy authorization string:%s" % e)

    def do_POST(self):

        uname=self.check_uname_secret();
        if uname:

            try:
                env = {}
                env['GATEWAY_INTERFACE'] = 'CGI/1.1'
                env['SERVER_PROTOCOL'] = self.protocol_version
                env['REQUEST_METHOD'] = self.command
                if self.headers.typeheader is None:
                    env['CONTENT_TYPE'] = self.headers.type
                else:
                    env['CONTENT_TYPE'] = self.headers.typeheader

                length = self.headers.getheader('content-length')
                if length:
                    env['CONTENT_LENGTH'] = length

                form = cgi.FieldStorage(fp=self.rfile,headers = None, environ=env)
                if self.path.startswith(self.delete_path):
                    self.delete_from_whitelist(form,uname)
                else:
                    self.add_to_whitelist(form,uname)

            except Exception,e:
                self.failed(e) 
    
    def do_GET(self):

        uname=self.check_uname_secret()
        if uname:
            try:
                dbh=DB.DBO()
                if self.path.startswith(self.add_path):
                    #This is a http request
                    param_start=self.path.index("?")
                    results=cgi.parse_qs(self.path[param_start+1:].replace("?","%3F"))
                    dom=self.domain_sanitise(results["domain"][0])
                    if dom:
                        self.wfile.write(self.print_form(url=results["url"][0],domain=results["domain"][0],clientaddr=results["clientaddr"][0],username=uname))
                        dbh.execute("insert into not_whitelisted set domain=%r, username=%r, protocol=%r, firstseen=NOW(), lastseen=NOW(), hitcount=1 on duplicate key update lastseen=NOW(), hitcount=hitcount+1",(dom,uname,"HTTP"))


                elif not(self.path.startswith("http")):
                    #The path for ssl requests just looks like "/favicon.ico"
                    #i.e. no https:// in front
                    if self.protocol=="SSL":
                        host = self.domain_sanitise(self.headers["Host"])
                        if host:
                            self.wfile.write(self.print_form(domain=host,url="https://%s%s" % (self.headers["Host"],self.path),username=uname))
                            dbh.execute("insert into not_whitelisted set domain=%r, username=%r, protocol=%r, firstseen=NOW(), lastseen=NOW(), hitcount=1 on duplicate key update lastseen=NOW(), hitcount=hitcount+1",(host,uname,"SSL"))
                    else:
                        self.failed("Receive a SSL request for %s without CONNECT" % self.path)

                elif self.path.startswith(self.captcha_path):
                    req_id=self.path.replace(self.captcha_path,"").strip()
                    if req_id.isalnum() and len(req_id)==self.captcha_id_length:
                        global captcha_factory
                        test = captcha_factory.get(req_id)
                        if test:
                            self.send_response(200)
                            self.send_header("Content-Type", "image/jpeg")
                            self.end_headers()
                            test.render().save(self.wfile, "JPEG")
                            return 
                    self.failed_screen("Bad captcha request")

                elif self.path.startswith(self.whitetrash_admin_path):

                    if self.path.startswith("%s/not_whitelisted" % self.whitetrash_admin_path):
                        global last_modified_not_whitelist
                        self.generate_webpage(last_modified_not_whitelist,self.regenerate_not_whitelist)
                    elif self.path.startswith("%s/deleteentry" % self.whitetrash_admin_path):
                        self.generate_delete_list(uname)

                    else:
                        global last_modified
                        self.generate_webpage(last_modified,self.regenerate_whitelist)

                else:
                    self.failed("Bad path: %s" % self.path)

            except Exception,e:
                self.failed("Error:%s. Path:%s" % (e,self.path))

    def do_CONNECT(self):
        self.auth_string=self.headers['Proxy-Authorization']
        self.ssl_username=decodestring(self.auth_string.split(" ")[1]).split(":")[0]
        self.send_response(200, 'OK')
        self.end_headers()

        #Switch our socket to SSL
        ctx = SSL.Context(SSL.SSLv23_METHOD)
        #server.pem's location (containing the server private key and
        #the server certificate).
        ctx.use_privatekey_file (config["ssl_server_certificate"])
        ctx.use_certificate_file(config["ssl_server_certificate"])
        ssl_socket = SSL.Connection(ctx, self.wfile)
        self.rfile = socket._fileobject(ssl_socket, "rb", self.rbufsize)
        self.wfile = socket._fileobject(ssl_socket, "wb", self.wbufsize)
        ssl_socket.set_accept_state()
        self.protocol="SSL"
        self.handle()

class CachedWTHTTPRequestHandler(WTHTTPRequestHandler):
#TODO:Just add this logic into existing server rather than writing subclass?

    def add_to_db(self,domain,user,protocol,url,comment,orig_url):
        """Insert into domain into DB and memcache.
        This is not strictly necessary since the redirector will pull it into cache on the first access, but
        we might as well save another access per new domain by adding it now.
        """
        try:
            dbh=DB.DBO()
            dbh.execute("insert into whitelist set domain=%r,timestamp=NOW(),username=%r,protocol=%r,originalrequest=%r,comment=%r", (domain,user,protocol,url,comment))
            cache.set("|".join((domain,protocol)),str(dbh.autoincrement()))
            #Need to remove any entry from the not_whitelisted table
            dbh.execute("delete low_priority from not_whitelisted where domain=%r and protocol=%r", (domain,protocol))
            self.success(orig_url,user,domain)
        except Exception,e:
            self.failed(e)

    def do_delete(self,delete_statement,args):
        """Perform the delete from database and memcached.
        
        We go back to the database to grab domain and protocol to be removed from the whitelist.
        This is a bit of overhead, but deleting doesn't happen very often.  This way we can also stop
        users from removing each others entries from the memcache - not that this matters too much because
        it would just be dragged back from the DB on next access anyway.

        The other option is to also submit the domain and protocol info in the webform along with ID.
        Again this allows users to remove others entries from the cache by tampering with the form, but it
        doesn't matter too much.
        """
        dbh=DB.DBO()
        check_select_stmt=delete_statement.replace("delete low_priority","select domain,protocol")
        dbh.execute(check_select_stmt,args)
        for row in dbh:
            cache.delete("|".join((row["domain"],row["protocol"])))
        dbh.execute(delete_statement, args)
        self.keys_deleted()

class WhitetrashServer(SocketServer.ThreadingMixIn, BaseHTTPServer.HTTPServer):
    pass

def double_fork(PIDFILE,LOGFILE):
    """Do Unix double-fork magic"""

    try:
        pid = os.fork()
        if pid > 0:
            # exit first parent
            sys.exit(0)
    except OSError, e:
        print >>sys.stderr, "fork #1 failed: %d (%s)" % (e.errno, e.strerror)
        sys.exit(1)

    # decouple from parent environment
    os.chdir("/")   # don't prevent unmounting
    os.setsid()
    os.umask(0)

    # do second fork
    try:
        pid = os.fork()
        if pid > 0:
            # exit from second parent, print eventual PID before
            open(PIDFILE,'w').write("%d"%pid)
            sys.exit(0)
    except OSError, e:
        print >>sys.stderr, "fork #2 failed: %d (%s)" % (e.errno, e.strerror)
        sys.exit(1)

    # redirect outputs to a log file
    sys.stdout = sys.stderr = Log(open(LOGFILE, 'a+'))


def run_http(server_class=WhitetrashServer,
        handler_class=WTHTTPRequestHandler):

    if config["use_memcached"].upper()=="TRUE":
        handler_class=CachedWTHTTPRequestHandler

    server_address = (config["server_address"], int(config["server_port"]))
    httpd = server_class(server_address, handler_class)
    syslog.openlog('whitetrash_serv',0,syslog.LOG_DAEMON)     
    PIDFILE = config["pidfile"]
    DAEMON = True 
    LOGFILE = config["logfile"]

    if (DAEMON):
        double_fork(PIDFILE,LOGFILE)
	syslog.syslog("***** Whitetrash Server Started - %s *****" % (str(time.asctime())))

    httpd.serve_forever()

if __name__ == "__main__":
    run_http()



