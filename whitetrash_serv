#!/usr/bin/env python

# Author: gregsfdev@users.sourceforge.net
# License: GPL
#
# This file is part of Whitetrash.
# 
#     Whitetrash is free software; you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation; either version 2 of the License, or
#     (at your option) any later version.
# 
#     Whitetrash is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
# 
#     You should have received a copy of the GNU General Public License
#     along with Whitetrash; if not, write to the Free Software
#     Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# 

import BaseHTTPServer, SimpleHTTPServer, SocketServer
import os,sys,time,cgi
import socket
import syslog
from base64 import decodestring
import re,urllib
import datetime
import MySQLdb
import MySQLdb.cursors
import whitetrash_db.DB as DB
import threading
from OpenSSL import SSL
from string import join
from whitetrash_db.configobj import ConfigObj

config = ConfigObj("/etc/whitetrash.conf")["DEFAULT"]

last_modified="Thu, 01 Jan 1970 00:00:00 GMT"
proxy_secret_check=re.compile(config["proxy_secret"])

class Log:
    """ The class for logging to a file.  Contains a flush after every write to ensure everything is logged even during an unexpected exit."""
    def __init__(self, f):
        self.f = f
    def write(self, s):
        self.f.write(s)
        self.f.flush()

def print_http_form(domain=None, url=None, clientaddr=None, username=None):

    return """
    <html>
    <head>
        <title>Internet Access Request Form</title>
        <style type="text/css" title="currentStyle" media="screen">
            @import "%s/whitetrash_server.css";
        </style>
    </head>

    <body>
        <div id="pageHeader"></div>
        <h1>Internet Access Request</h1>
        <form action="http://whitetrash" method="post">
        <div id="host"><div id="hostText"><p><b>Host Requested: </b></p></div><input name="domain" id="hostInputText" value="%s" maxlength="70" size="30" type="text"></div>
        <div id="requestDetails">
        <div id="requestDetailsText">
        <p><b>Protocol: </b>HTTP</p>
        <p><b>Client IP: </b>%s</p>
        <p><b>Client Username: </b>%s</p>
        </div>
        </div>
        <div id="centreContent">
        <p><b>Full Request: </b>%s</p>
        <div id="bnessReq">
        <p><b>This site is not currently in the whitelist.  If you have a genuine need to access this site please enter a business requirement or comment for this domain: </b><input name="comment" id="bnessInput" maxlength="100" size="40" type="text"></p></div>
        <div id="warningText">
        <p>By clicking "I Agree" below you are agreeing to have the information above stored on a list of whitelisted websites with YOUR UNIQUE USERNAME at <a href="http://viewwhitelist/whitelist.html">this address</a></p></div>
        <input type="hidden" name="url" value="%s">
        <input type="hidden" name="user" value="%s">
        <input type="hidden" name="protocol" value="HTTP">
        <input type="submit" name="consent" id="submit" value="I Agree" class="LgnBtn">
        </div>
        </form>
    </html>
    """ % (config["stylesheet_server"],domain,clientaddr,username,url,url,username)

def print_ssl_form(domain=None, url=None, clientaddr=None, username=None):

    return """
    <html>
    <head>
        <title>Internet Access Request Form</title>
        <style type="text/css" title="currentStyle" media="screen">
            @import "%s/whitetrash_server.css";
        </style>
    </head>

    <body>
        <div id="pageHeader"></div>
        <h1>Internet Access Request</h1>
        <form action="https://whitetrash" method="post">
        <div id="host"><div id="hostText"><p><b>Host Requested: </b></p></div><input name="domain" id="hostInputText" value="%s" maxlength="70" size="30" type="text"></div>
        <div id="requestDetails">
        <div id="requestDetailsText">
        <p><b>Protocol: </b>SSL</p>
        </div>
        </div>
        <div id="centreContent">
        <p><b>Full Request: </b>%s</p>
        <div id="bnessReq">
        <p><b>This site is not currently in the whitelist.  If you have a genuine need to access this site please enter a business requirement or comment for this domain: </b><input name="comment" id="bnessInput" maxlength="100" size="40" type="text"></p></div>
        <div id="warningText">
        <p>By clicking "I Agree" below you are agreeing to have the information above stored on a list of whitelisted websites with YOUR UNIQUE USERNAME at <a href="http://viewwhitelist/whitelist.html">this address</a></p></div>
        <input type="hidden" name="url" value="%s">
        <input type="hidden" name="user" value="%s">
        <input type="hidden" name="protocol" value="SSL">
        <input type="submit" name="consent" id="submit" value="I Agree" class="LgnBtn">
        </div>
        </form>

    </html>
    """ % (config["stylesheet_server"],domain,url,url,username)

class HTTPRequestHandler(SimpleHTTPServer.SimpleHTTPRequestHandler):

    def setup(self):
        SimpleHTTPServer.SimpleHTTPRequestHandler.setup(self)
        self.protocol="HTTP"
        self.auth_string=""

    def failed(self,e):
        self.wfile.write("""
        <html>

        <head>
        <title>Whitetrash Error</title>
        <style type="text/css" title="currentStyle" media="screen">
            @import "%s/whitetrash_server.css";
        </style>

        </head>

        <body>

        <div id="pageHeader"></div>
        <div id="centreContent">
        <div id="errorText">
        <h1>Error</h1>
        <p>
        Please contact your friendly sysadmin.  Error details as follows:
        <p>
        <hr>
        <p>%s</p>
        </div>
        </div>

        </body>

        </html>

        """ % (config["stylesheet_server"],e))

    def success(self,orig_url,user,domain):
        dateobj=datetime
        self.wfile.write(""" 
        <html>

        <head>
        <title>Access Granted</title>
        <meta http-equiv=\"refresh\" CONTENT=\"1;URL=%s\">
        <style type="text/css" title="currentStyle" media="screen">
            @import "%s/whitetrash_server.css";
        </style>

        </head>

        <body>

        <div id="pageHeader"></div>
        <div id="requestDetails">
        <div id="requestDetailsText">
        <p><b>Timestamp: </b>%s</p>
        <p><b>Domain: </b>%s</p>
        <p><b>Client Username: </b>%s</p>
        </div>
        </div>
        
        <div id="centreContent">
        <h1>Thank you %s</h1>
        <p>
        Your access request for:</p>
        <p>%s</p>
        <p>has been granted.  Your browser should automatically take you to the website. If it doesn't you can use this link:</p>
        <p><a href=\"%s\">%s</a></p>
        </div>


        </body>

        </html>

        """ % (orig_url,config["stylesheet_server"],str(dateobj.datetime.now()),domain,user,user,orig_url,orig_url,orig_url))

    def convert_epoch(self,timestring):
        return time.mktime(time.strptime(timestring.strip(), "%a, %d %b %Y %H:%M:%S %Z"))

    def send_200(self,new_time,cache_age_secs,length):
        self.send_response(200, 'OK')
        syslog.syslog("Sending 200, Last-Modified:%s" % new_time)
        self.send_header('Content-type','text/html')
        self.send_header("Accept-Ranges", "bytes")
        self.send_header("Cache-Control","max-age=%s" % cache_age_secs)
        
        ##Add an expires header for http 1.0 caches
        #convert to epoch and add cache age in seconds
        epoch=self.convert_epoch(new_time)+cache_age_secs
        age=time.strftime("%a, %d %b %Y %H:%M:%S",time.localtime(epoch))+" GMT"
        self.send_header("Expires",age)

        self.send_header('Content-length', length)
        self.send_header("Last-Modified",new_time)
        self.end_headers()

    def send_304(self,last_modified):
        self.send_response(304,"Not Modified")
        syslog.syslog("Sending 304 Not Modified")
        self.send_header("Date",self.date_time_string())
        self.send_header("Last-Modified",last_modified)
        self.end_headers()

    def regenerate_whitelist(self,cache_age_in_seconds):
        """Create the html representing the whitelist from the database"""

        global last_modified

        syslog.syslog("Regenerating whitelist webpage")
        dbh=DB.DBO()
        dbh.execute("select whitelist_id,domain,timestamp,username,protocol,comment,originalrequest from whitelist order by username,whitelist_id")
        table=""
        #I don't unquote the original domain urllib.unquote(row[4]) due to the potential for code injection.
        for row in dbh:
            table+="<tr><td>%s</td><td>%s</td><td>%s</td><td>%s</td><td>%s</td><td>%s</td><td>%s</td></tr>\n" %(row['whitelist_id'],row['domain'],row['timestamp'],row['username'],row['protocol'],row['comment'],row['originalrequest'])
        whitelist_htmlpage="""

        <html>
        <head>
        <title>HTTP Whitelist Report</title>
        <style type="text/css" title="currentStyle" media="screen">
            @import "%s/whitetrash_server.css";
        </style>
        </head>

        <body>

        <div id="pageHeader"></div>
        <h1>Whitelist</h1>
        <div id="whitelistTable">
        <p>
        Report generated at %s.
        <p>
        
        <table border=1 frame=box>
        <tr><td><b>ID</b></td><td><b>Whitelisted Domain</b></td><td><b>Timestamp (local)</b></td><td><b>Username</b></td><td><b>Protocol</b></td><td><b>Comment</b></td><td><b>Original Request</b></td></tr>
        %s
        </table>
        </div>

        </body>
        </html>""" % (config["stylesheet_server"],time.asctime(),table)
        current_time=self.date_time_string()    
        last_modified=current_time
        self.send_200(current_time,cache_age_in_seconds,len(whitelist_htmlpage))

        self.wfile.write(whitelist_htmlpage)

    def generate_whitelist_webpage(self):
        """I was originally caching this page locally, but it is much simpler and performs better if I just set the If-Modified-Since header and let squid do the caching!
        This approach is much better, as the page only gets regenerated if it has been requested.  Before I was using a cron which always ran, regardless of whether anyone
        was actually interested.

        This is mainly for my benefit to remember how this works:

        - Firefox respects the max-age caching directive and will not ask squid for a new copy of the page unless the time has expired, OR the user hits refresh.  If the user
        refreshes, firefox adds a "Cache-Control: max-age=0" header to the request.
        - Squid will always treat a max-age=0 as a MISS and ask the server for a new copy.  If there is no max-age=0 and the cache time hasn't expired, squid will treat
        it as a HIT.
        - Firefox only supplies a IMS header with the request if it receive a Last-Modified header with the last response. IMS *is sent* with a refresh. 
        
        """

        try:
            global last_modified

            #syslog.syslog("Full Request Headers: %s" % self.headers)
            try:
            
                if (time.time() + time.timezone - self.convert_epoch(last_modified) > int(config["cache_age_in_seconds"])):
                    #syslog.syslog("Time difference:%s"% (time.time() +time.timezone - self.convert_epoch(last_modified)))
                    #Time to refresh
                    last_modified="Thu, 01 Jan 1970 00:00:00 GMT"
                    
                #syslog.syslog("IMS from request: %s.  Our last modified time: %s" % (self.headers['If-Modified-Since'],last_modified))

                if self.headers['If-Modified-Since']==last_modified:
                    self.send_304(last_modified)
                else:
                    self.regenerate_whitelist(int(config["cache_age_in_seconds"]))
            except KeyError:
                #No IMS header so we have to regenerate
                self.regenerate_whitelist(int(config["cache_age_in_seconds"]))

        except Exception,e:
            self.failed("Error running whitelist html page generation: %s" %e)
        
    def add_to_whitelist(self,form,authenticated_user):

        try:
            #All of these fields need to be sanitised.
            orig_comment=str(form.getfirst("comment"))[:DB.COMMENT_LEN]
            orig_url=str(form.getfirst("url"))[:DB.URL_LEN]
            #User comes from squid so we trust it
            user=str(form.getfirst("user"))
            domain=str(form.getfirst("domain"))[:DB.DOMAIN_LEN]
            protocol=str(form.getfirst("protocol")).upper()
            if orig_url and domain and protocol:

                if (protocol !="HTTP" and protocol!="SSL"):
                    self.failed("Bad protocol, only HTTP and SSL handled")

                else:
                
                    if (protocol=="HTTP") and (authenticated_user != user):
                        # We don't get this info for SSL, so just check if it is HTTP
                        # Doesn't matter too much since we ignore the form value anyway
                        self.failed("Invalid user authentication")

                    else:

                        #Only trust the user provided by squid, not the one from the form.    
                        user=authenticated_user

                        if not orig_comment:
                            orig_comment="None"

                        #Quote the url to get rid of any dangerous stuff for the DB, but still display the proper text when viewed in a browser.
                        url=urllib.quote(orig_url.lower())
                        #Only allow sane text in the comment.
                        comment=re.sub("[^a-zA-Z0-9- .,!]+","",orig_comment)

                        #sanitise domain
                        domain=form.getfirst("domain").lower()
                        #Make sure it is of something.com format
                        domain_sanitise=re.compile("^([a-z0-9-]{1,50}\.){1,6}[a-z]{2,6}$")
                        domain_res=domain_sanitise.match(domain)
                        if domain_res:
                            #Domain is valid.
                            domain=domain_res.group()
                            domain=re.sub("^www[0-9]?\.","",domain,1)

                            try:
                                dbh=DB.DBO()
                                dbh.execute("insert into whitelist set domain=%r,timestamp=NOW(),username=%r,protocol=%r,originalrequest=%r,comment=%r", (domain,user,protocol,url,comment))

                                self.success(orig_url,user,domain)
                            except Exception,e:
                                self.failed(e)
                        else:
                            #Decided to fail rather than change to a valid domain name.
                            self.failed("Bad domain name")
            else:
                self.failed("Incomplete fields")
        except Exception,e:
            self.failed("Invalid input:%s" % e)

    def do_POST(self):

        try:
            #Get the username and the "secret" passed by squid.
            #Header looks like: "Basic sldkfjlssjd\r\n"
            (uname,secret)=decodestring(self.headers['Proxy-Authorization'].split()[1]).split(":")

        except Exception,e:
            if self.protocol=="SSL":
                message = "do_POST: Problem decoding authorization string (Proxy-Authorization: %s) '%s'" % self.auth_string,e
            else:
                message = "do_POST: Problem decoding authorization string (Proxy-Authorization: %s) '%s'" % self.headers['Proxy-Authorization'],e
            self.failed(message)

        try:
           
            if proxy_secret_check.match(secret):

                if uname.isalnum():
                    #This is a simple check
                    #Username is alpha-numeric
                    env = {}
                    env['GATEWAY_INTERFACE'] = 'CGI/1.1'
                    env['SERVER_PROTOCOL'] = self.protocol_version
                    env['REQUEST_METHOD'] = self.command
                    if self.headers.typeheader is None:
                        env['CONTENT_TYPE'] = self.headers.type
                    else:
                        env['CONTENT_TYPE'] = self.headers.typeheader

                    length = self.headers.getheader('content-length')
                    if length:
                        env['CONTENT_LENGTH'] = length

                    form = cgi.FieldStorage(fp=self.rfile,headers = None, environ=env)
                    self.add_to_whitelist(form,uname)
                else:
                    #User name invalid
                    self.failed("Expecting alphanumeric username, got:%s" % uname)
            else:
                self.failed("Invalid cache_peer password for whitetrash")

        except Exception,e:
            self.failed(e) 
        
    def do_GET(self):
        #print self.path
        if "viewwhitelist" in self.path:
            
            self.generate_whitelist_webpage()

        else:
            try:
                if self.protocol=="SSL":
                    print self.headers["Host"], self.path
                    self.wfile.write(print_ssl_form(domain=self.headers["Host"],url="https://%s%s" % (self.headers["Host"],self.path),clientaddr="0.0.0.0",username="ssl"))
                else:
                    param_start=self.path.index("?")
                    results=cgi.parse_qs(self.path[param_start+1:].replace("?","%3F"))
                    self.wfile.write(print_http_form(url=results["url"][0],domain=results["domain"][0],clientaddr=results["clientaddr"][0],username=results["clientident"][0]))
            except KeyError,e:
                self.failed("Invalid domain requested")
            except Exception,e:
                self.failed("Error:%s. Path:%s" % (e,self.path))

    def do_CONNECT(self):
        self.auth_string=self.headers['Proxy-Authorization']
        self.send_response(200, 'OK')
        self.end_headers()

        ctx = SSL.Context(SSL.SSLv23_METHOD)
        #server.pem's location (containing the server private key and
        #the server certificate).
        ctx.use_privatekey_file (config["ssl_server_certificate"])
        ctx.use_certificate_file(config["ssl_server_certificate"])
        ssl_socket = SSL.Connection(ctx, self.wfile)
        self.rfile = socket._fileobject(ssl_socket, "rb", self.rbufsize)
        self.wfile = socket._fileobject(ssl_socket, "wb", self.wbufsize)
        ssl_socket.set_accept_state()
        self.protocol="SSL"
        self.handle()


class WhitetrashServer(SocketServer.ThreadingMixIn, BaseHTTPServer.HTTPServer):
    pass

def run_http(server_class=WhitetrashServer,
        handler_class=HTTPRequestHandler):
    server_address = (config["server_address"], int(config["server_port"]))
    httpd = server_class(server_address, handler_class)
    syslog.openlog('whitetrash_serv',0,syslog.LOG_DAEMON)     
    PIDFILE = config["pidfile"]
    DAEMON = True 
    LOGFILE = config["logfile"]

    if (DAEMON):
        # Unix double-fork magic
        try:
            pid = os.fork()
            if pid > 0:
                # exit first parent
                sys.exit(0)
        except OSError, e:
            print >>sys.stderr, "fork #1 failed: %d (%s)" % (e.errno, e.strerror)
            sys.exit(1)

        # decouple from parent environment
        os.chdir("/")   # don't prevent unmounting
        os.setsid()
        os.umask(0)

        # do second fork
        try:
            pid = os.fork()
            if pid > 0:
                # exit from second parent, print eventual PID before
                open(PIDFILE,'w').write("%d"%pid)
                sys.exit(0)
        except OSError, e:
            print >>sys.stderr, "fork #2 failed: %d (%s)" % (e.errno, e.strerror)
            sys.exit(1)
    
    
        # redirect outputs to a log file
        sys.stdout = sys.stderr = Log(open(LOGFILE, 'a+'))
	syslog.syslog("***** Whitetrash Server Started - %s *****" % (str(time.asctime())))

    httpd.serve_forever()

run_http()



